function [S_vec,ST_vec,SJ,STJ,Y,t,M,y_exp] = sens_methods(model,Par,N,SensMethod,SampleMethod,y_exp)
% [S_vec,ST_vec,SJ,STJ,Y,t,M] = sens_methods(model,Par,N,SensMethod,SampleMethod,y_exp)
% Global sensitivity analysis of dynamical systems implemented in Simulink using
% variance-based SensMethod and with combinations of parameters generated by
% Monte Carlo SensMethod with an uniform probability distribution function.
% This tool needs the Statistics Toolbox
%
% See paper: Saltelli A., et al, "Variance based sensitivity analysis of model output.
% Design and estimator for the total sensitivity index". Computer Physics Communications,
% 181(2), 259–270, 2010.
%
% model         Simulink model name. Example: 'Pendulum'. The Simulink model has to be set correctly:
%               (1) the name of parameters are p(1), p(2),...;
%               (2) connect an "Out block" to the output;
%               (3) in "Configuration parameters | Data Import/Export" check these options: Time (tout),
%               Output (yout), Save simulation output as single object
%               (4) use fixed-step solver;
%               (5) if there are problems with rate transition, then fix the problem in
%               Configuration | Diagnostics | Sample time.
% Par           Cell (Npx1) with information about Np parameters
%               {'Parameter_name', 'Uncertainty_mode', uncertainty_value}
%                   Uncertainty_mode = 'range', uncertainty_value = [min, max]
%                   Uncertainty_mode = 'std', uncertainty_value = [nominal, standard_deviation]
%                   Uncertainty_mode = 'percent', uncertainty_value = [nominal, percent(0,100)]
% N             Sample size (number of sets of parameters to test)
% SensMethod    Variance-based SensMethod: 'Saltelli', 'Sobol', 'Jansen', 'brute-force'
% SampleMethod  'Uniform','LatinHypercube'
% y_exp         (Optional) Experimental time response for compute of SJ and STJ. If it is
%                 not specified, y_exp is the time response with nominal parameters
% S_vec         Matrix with fractional sensitivity indices in every time instant t
%                 (a column by factor and a row by time instant t)
% ST_vec        Matrix with total sensitivity indices in every time instant t
%                 (a column by factor and a row by time instant t)
% SJ            Fractional sensitivity indices for mean squared error (MSE) function
% STJ           Total sensitivity indices for mean squared error (MSE) function
% Y             Matrix (NxNd) with time responses in rows to sets M of parameters
% t             Time vector t with Nd data
% M             Matrix (NxNp) of input parameters (one parameter by column and one sample by row)
%
% (c) Carlos Mario Vélez S. 2015
% Universidad EAFIT, http://www.eafit.edu.co
% Medellín, Antioquia, Colombia
% E-mail: cmvelez@eafit.edu.co
% https://plus.google.com/+CarlosMVelezS/about

Np = size(Par,1); % Number of parameters
% Nominal parameters
Pnom = zeros(1,Np);
Rnom = zeros(2,Np);
for k = 1:Np
    switch Par{k,2}
        case 'std'
            Pnom(k) = Par{k,3}(1);
            Rnom(:,k) = [Par{k,3}(1)-Par{k,3}(2) ; Par{k,3}(1)-Par{k,3}(2)];
        case 'percent'
            Pnom(k) = Par{k,3}(1);
            Rnom(:,k) = [Par{k,3}(1)-Par{k,3}(2)*Par{k,3}(1)/100 ; Par{k,3}(1)+Par{k,3}(2)*Par{k,3}(1)/100];
        case 'range'
            Pnom(k) = (Par{k,3}(1)+Par{k,3}(2))/2;
            Rnom(:,k) = [Par{k,3}(1) ; Par{k,3}(2)];
    end
end

if (nargin < 6) || strcmp(y_exp,'') || isempty(y_exp)
    % Nominal time response
    load_system(model)
    hws = get_param(model, 'ModelWorkspace');
    hws.assignin('p', Pnom);
    simOutArray = sim(model,'ReturnWorkspaceOutputs', 'on');
    y_exp = simOutArray.get('yout')';
end

% Generation of matrix M (N x Np) with all parameters for uncertanity and sensitivity analysis
% (one parameter by row and one sample by column)
% M = [p1(1)  p2(1)  ... pNp(1);
%      p1(2)  p2(2)  ... pNp(2);
%             ...
%      p1(N)  p2(N)  ... pNp(N)]

switch SampleMethod
    case 'Uniform'
        M = zeros(N,Np);
        for k = 1:Np
            pdfun = makedist('Uniform','lower',Rnom(1,k),'upper',Rnom(2,k));
            M(:,k) = random(pdfun,1,N); % Normal distribution between two values given by the range of parameters
        end
        
    case 'LatinHypercube'
        M = lhsdesign(N,Np).*( ones(N,1)*(Rnom(2,:)-Rnom(1,:)) ) + ones(N,1)*Rnom(1,:);
        % latinHypercube between min(Par) and max(Par)
    otherwise
        clc
        disp('---------------------------------------')
        disp('Error ... Give the right name of Sample Method')
        disp('---------------------------------------')
        return
end

switch SensMethod
    
    case 'brute-force'
        Nsim = N + Np*N^2; % Number of Montecarlo simulations
        [Y,t] = sens_montecarlo(model,M, [0, Nsim]); % Y is a matrix (NxNd) with time responses in rows
        Nd = size(t,2); % Number of simulation data
        Y_nom = ones(N,1)*y_exp;
        J = sum((Y-Y_nom).^2,2); % Scalar model output
        % Generation of (1xNp) cell with all combinations of parameters for calculation of
        % fractional variances. Every matrix has dimension (N^2xNp)
        % Mi{i} = [p1(1) ... pi(1) ... pNp(1);
        %          ...        ...       ...
        %          p1(N) ... pi(1) ... pNp(N);
        %          ---------------------------
        %          ...        ...       ...
        %          ---------------------------
        %          p1(1) ... pi(N) ... pNp(1);
        %          ...        ...       ...
        %          p1(N) ... pi(N) ... pNp(N)]
        Mi = cell(1,Np);
        for k = 1:Np
            Mi{k} = repmat(M,N,1); % Creation of a large matrix consisting of tiling of N copies of M
            for i = 1:N
                Mi{k}((i-1)*N+1:i*N,k) = M(i,k)*ones(N,1); % The respective column has a constant value
            end
        end
        Yi = cell(1,Np);
        Ji = cell(1,Np);
        for k = 1:Np
            % Simulation with every set of parameters (row of Mi{k}) and storage
            % in matrix Yi (a cell for every parameter)
            [Yi{k},t] = sens_montecarlo(model,Mi{k},[N+(k-1)*N^2,Nsim]);
            Y_nom2 = ones(N^2,1)*y_exp;
            Ji{k} = sum((Yi{k}-Y_nom2).^2,2);
        end
        V_vec = var(Y,0,1); % Total variance in every sample time of every column
        Vi_vec = zeros(Np,Nd);
        VJ = var(J,0);
        VJi = zeros(Np,1);
        for k = 1:Np
            ymean = zeros(N,Nd);
            Jmean = zeros(N,1);
            for i = 1:N
                ymean(i,:) = mean(Yi{k}((i-1)*N+1:i*N,:),1);
                Jmean(i) = mean(Ji{k}((i-1)*N+1:i*N,:));
            end
            Vi_vec(k,:) = var(ymean,0,1); % Time-dependent fractional variances of every column
            % Vi = V[E(Y|p(i)=p*)] with p*=[pi1 ... piN]'
            VJi(k) = var(Jmean,0);
        end
        S_vec = zeros(Np,Nd);
        SJ = zeros(Np,1);
        for k = 1:Np
            S_vec(k,:) = Vi_vec(k,:)./V_vec; % Time-dependent fractional sensitivity indices
            SJ(k) = VJi(k)/VJ;
        end
        VTi_vec = zeros(Np,Nd); % Time-dependent total variances: VTi_vec=E[V(Y|p(~i)=p*)]
        VTJi = zeros(Np,1);
        for k = 1:Np
            vary = zeros(N,Nd);
            varJ = zeros(N,1);
            for i = 1:N
                vary(i,:) = var(Yi{k}(i:N:(N-1)*N+i,:),0,1);
                varJ(i) = var(Ji{k}(i:N:(N-1)*N+i,:),0);
            end
            VTi_vec(k,:) = mean(vary,1);
            VTJi(k) = mean(varJ);
        end
        ST_vec = zeros(Np,Nd);
        STJ = zeros(Np,1);
        for k = 1:Np
            ST_vec(k,:) = VTi_vec(k,:)./V_vec; % Time-depndent total sensitivity
            STJ(k) = VTJi(k)/VJ;
        end
        
    case {'Sobol','Jansen','Saltelli'}
        % A,B: Matrices (N/2xNp) with N/2 combinations of Np parameters. One parameter by column and
        % one sample by row. For example:
        % A = [p1(1)   p2(1)   ... pNp(1); p1(2)   p2(2) ... pNp(2); ... ; p1(N/2) p2(N/2) ... pNp(N/2)]
        A = M(1:N/2,:);
        B = M(N/2+1:N,:);
        % BAi matrices formed by all rows of B except the k column, which comes from A
        BAi = cell(1,Np);
        for k = 1:Np
            BAi{k} = B;
            BAi{k}(:,k) = A(:,k);
        end
        % ABi matrices formed by all colums of A except the k column, which comes from B
        ABi = cell(1,Np);
        for k = 1:Np
            ABi{k} = A;
            ABi{k}(:,k) = B(:,k);
        end
        
        if strcmp(SensMethod, 'Sobol')
            Nsim = N*(Np+1); % Number of Montecarlo simulations
        else
            Nsim = N*(Np/2+1); % Number of Montecarlo simulations
        end
        
        [YA,~] = sens_montecarlo(model,A,[0,Nsim]);
        [YB,t] = sens_montecarlo(model,B,[N/2,Nsim]); % dim(YA)=dim(YB)=(Nd x N/2)
        Y = [YA;YB];
        JA = sum((YA-ones(N/2,1)*y_exp).^2,2);
        JB = sum((YB-ones(N/2,1)*y_exp).^2,2);
        J = [JA;JB];
        Nd = size(t,2); % Number of simulation data
        S_vec = zeros(Np,Nd);
        ST_vec = zeros(Np,Nd);
        SJ = zeros(Np,1);
        STJ = zeros(Np,1);
        V_vec = var(Y,0,1); % Total variance (1xNd) of every column in every sample time
        VJ = var(J,0);
        YABi = cell(1,Np);
        YBAi = cell(1,Np);
        JABi = cell(1,Np);
        JBAi = cell(1,Np);
        
        switch SensMethod
            case 'Sobol'
                f02_vec = mean(Y,1).^2;
                f02 = mean(J)^2;
                for k = 1:Np
                    [YBAi{k},~] = sens_montecarlo(model,BAi{k},[k*N,Nsim]);
                    [YABi{k},t] = sens_montecarlo(model,ABi{k},[k*N+N/2,Nsim]);
                    JBAi{k} = sum((YBAi{k}-ones(N/2,1)*y_exp).^2,2);
                    JABi{k} = sum((YABi{k}-ones(N/2,1)*y_exp).^2,2);
                    S_vec(k,:) = ( mean( YA.*YBAi{k},1 ) - f02_vec )./V_vec;
                    ST_vec(k,:) = mean( YA.*(YA - YABi{k}),1 )./V_vec;
                    SJ(k) = ( mean( JA.*JBAi{k} ) - f02 )/VJ;
                    STJ(k) = mean( JA.*(JA - JABi{k}) )/VJ;
                end
            case 'Jansen'
                for k = 1:Np
                    [YABi{k},t] = sens_montecarlo(model,ABi{k},[N+(k-1)*N/2,Nsim]);
                    JABi{k} = sum((YABi{k}-ones(N/2,1)*y_exp).^2,2);
                    S_vec(k,:) = 1 - mean((YB - YABi{k}).^2,1)./(2*V_vec);
                    ST_vec(k,:) = mean( (YA - YABi{k}).^2,1 )./(2*V_vec);
                    SJ(k) = 1 - mean((JB - JABi{k}).^2)/(2*VJ);
                    STJ(k) = mean((JA - JABi{k}).^2)/(2*VJ);
                end
            case 'Saltelli'
                for k = 1:Np
                    [YABi{k},t] = sens_montecarlo(model,ABi{k},[N+(k-1)*N/2,Nsim]);
                    JABi{k} = sum((YABi{k}-ones(N/2,1)*y_exp).^2,2);
                    S_vec(k,:) = mean(YB.*(YABi{k} - YA),1)./V_vec;
                    ST_vec(k,:) = mean((YA - YABi{k}).^2,1)./(2*V_vec);
                    SJ(k) = mean(JB.*(JABi{k} - JA))/VJ;
                    STJ(k) = mean((JA - JABi{k}).^2)/(2*VJ);
                end
        end
        
    otherwise
        clc
        disp('---------------------------------------')
        disp('Error ... Give the right name of Sensitivity Method')
        disp('---------------------------------------')
        return
end

end
